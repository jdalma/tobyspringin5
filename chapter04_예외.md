
**JdbcTemplate**을 대표로 하는 **스프링의 데이터 엑세스 기능에 담겨 있는 예외 처리와 관련된 접근 방법에 대해 알아보자.**

```
예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다.
모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.

자바 언어와 JDK 초기 설계자들은 체크 예외를 발생 가능한 예외에 모두 적용하려고 했던 것 같다.
예외적인 상황에서 던져질 가능성이 있는 것들 대부분이 체크 예외로 만들어져 있다.
체크 예외의 불필요성을 주장하는 사람들이 늘어갔고, 예외 블랙홀이나 무책임한 throws를 남발하게 되었다.
최근에 새로 등장하는 자바 표준 스펙의 API 또는 오픈 소스 프레임워크들은 예상 가능한 예외상황을 다루는 예외를 체크 예외 대신 언체크 예외로 만드는 경향이 있다.

애플리케이션 로직상에서 예외조건이 발견되거나 예외상황이 발생할 수도 있다.
이런 것은 의도적으로 던지는 예외이기 때문에 "체크 예외"를 사용하는 것이 적절하다.
비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응이나 복구작업이 필요하기 때문이다.

런타임 예외 중심의 전략은 "낙관적인 예외처리 기법"이라고 할 수 있다.
복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 런타임 예외 이므로 시스템 레벨에서 알아서 처리해줄 것이고,
꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 겂이 없다는 낙관적인 태도를 기반으로 하고 있다.
이런 면에서 직접 처리할 수 없는 예외가 대부분이라고 하더라도 혹시 놓치는 예외가 있을 수 있으니, 일단 잡도록 강제하는 체크 예외의 "비관적인 접근 방법"과 대비된다. 
```

# **4.1 사라진 SQLException**

```java
// JdbcTemplate 적용 전
public void deleteAll() throws SQLException {
    this.jdbcContext.executeSql("delete from users");
}

// JdbcTemplate 적용 후
public void deleteAll() {
    this.jdbcTemplate.update("delete from users");
}
```

**JdbcTemplate** 적용 후에는 **SQLException**이 사라졌다.  
이 **SQLException** 어디로 사라진걸까?  

## 4.1.1 초난감 예외처리 ⭐️

### **예외를 잡아서 무시하거나 잡아먹어 버리는 코드는 만들지 마라**

예외를 잡아서 초치를 취할 방법이 없다면 잡지 말아야 한다. <br>
메소드에 `throws SQLException`을 선언해서 메소드 밖으로 던지고 자신을 호출한 코드에게 예외를 전가해버려라.

### **무의미하고 무책임한 `throws`**

`throws Exception`을 기계적으로 붙이는 개발자도 있다. <br>
위와 같은 무책임한 예외 전가는 개발자에게 의미있는 정보를 전달할 수 없다. <br>

**정말 무엇인가 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 그냥 복사해서 붙여놓은 것인지 알 수가 없다.** <br>
결국 무책임한 예외를 전가하는 메소드를 사용하는 메소드 역시 `throws Exception`을 따라 붙일 수 밖에 없다. <br>
결과적으로 **적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.**

## 4.1.2 예외의 종류와 특징 ⭐️

예외를 어떻게 처리해야할까? <br>
가장 큰 이슈는 **체크 예외 `checked exception`** 라고 불리는 **명시적인 처리가 필요한 예외**를 사용하고 다루는 방법이다. <br>
`throw`를 통해 발생시킬 수 있는 예외는 크게 세 가지다.

1. **Error**
   - `java.lang.Error` 클래스의 서브 클래스들
   - 시스템에 뭔가 비정상적인 상황이 발생했을 경우
   - 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다.
   - 따라서 **애플리케이션에서는 이런 에러에 대한 처리는 신경쓰지 않아도 된다.**
2. **Exception과 체크 예외**
   - `java.lang.Exception` 클래스와 그 서브클래스
   - `Error`와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.
   - `Exception` 클래스는 **체크 예외**와 **언체크 예외**로 구분된다.
   - **체크 예외** : `Exception`클래스의 서브 클래스이면서 `RuntimeException`을 상속하지 않은 것들
   - **언체크 예외** : `RuntimeException`을 상속한 클래스
   - 일반적으로 예외라고하면 **체크 예외**라고 생각하면 된다.
3. **RuntimeException과 언체크/런타임 예외**
   - `java.lang.RuntimeException` 클래스를 상속한 예외들
   - 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들
   - 대표적으로 NullPointerException, IllegalArgumentException 등

## 4.1.3 예외처리 방법 ⭐️

1. **예외복구**
   - 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
2. **예외처리 회피**
   - 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
   - 예외를 복구하는 것 처럼 **의도가 분명해야 한다.**
   - 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 **분명한 확신이 있어야 한다.**
3. **예외 전환**
   - 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것
   - 하지만 **예외처리 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 `적절한 예외로 전환해서 던진다`는 특징이 있다.**
   
### 예외 전환의 두 가지 목적

**첫 번째**  
내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우, **의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해**  
보통 전환하는 예외에 원래 발생한 예외(`getCause()` , `initCause()`)를 담아서 **중첩 예외**로 만드는 것이 좋다.    

**두 번째**
예외를 처리하기 쉽고 단순하게 만들기 위해 **포장**하는 것이다.  
중첩 예외를 이용해 새로운 예외를 만들고 **원인**이 되는 예외를 내부에 담아서 던지는 방식은 같다.  
하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다.    
주로 예외처리를 강제하는 **체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.**  
어차피 **복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야 한다.**

## 4.1.4 예외처리 전략

예외를 효과적으로 사용하고, 예외가 발생하는 코드를 깔끔하게 정리하는 데는 여러 가지 신경 써야 할 사항이 많다.  

### `add()` 메소드 예외처리

충분히 복구가 가능한 `DuplicateUserIdException` 런타임 예외
- 런타임 예외도 `throws`를 선언할 수 있다
대부분 복구가 불가능한 `SQLException` 체크 예외는 `throws`를 타고 앞으로 전달되게 하지말고 **런타임 예외로 전환하자**  

```java
public class DuplicateUserIdException extends RuntimeException {
    public DuplicateUserIdException(Throwable cause) {
        super(cause);
    }
}

...

public void add(final User user) throws DuplicateUserIdException {
     try { 
        // 사용자 저장 로직
        
     } catch (SQLException e) {
        if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) {
            throw new DuplicateUserIdException(e.getCause());
         }
         throw new RuntimeException(e);
     }
}
```

## 4.1.5 SQLException은 어떻게 됐나?

스프링의 **예외처리 전략과 원칙**을 잘 알고 있어야 한다.  
먼저 생각해 볼 사항은 **99%의 `SQLException`은 복구가 불가능한 예외인 것**  
더군다나 DAO 밖에서 `SQLException`을 다룰 수 있는 가능성은 거의 없다.  

따라서 예외처리 전략을 적용해야 한다. 가능한 빨리 언체크/런타임 예외로 전환해줘야 한다.
스프링의 **JdbcTemplate**은 이 예외처리 전략을 따르고 있다.  
**JdbcTemplate 템플릿과 콜백안에서 발생하는 모든 SQLException을 런타임 예외인 `DataAccessException`으로 포장해서 던져주기 때문에 `throws SQLException`이 사라진 것이다.**  


# **4.2 예외 전환**
